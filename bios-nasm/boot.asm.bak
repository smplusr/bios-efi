[bits 16]
[org 0x7c00]




preload:	mov	ax, 0x1000
		mov	si, ax
		mov	di, ax


boot:		xor	ax, ax		; sets AH to 00h (bios keyboard read)
		int	0x16		; IVT call for bios keyboard read
		mov	[si], ax	


		call	langeval
		call	instout


		jmp	$

.loop:		jmp	boot




instout:	push	ax

		lodsb
		mov	ah, 0xe
		int	0x10

		pop	ax
		ret


extprint:	push	ax
		push	si

		mov	dx, si
		mov	si, di

.print:		lodsb
		mov	ah, 0xe
		int	0x10
		
		cmp	si, dx
		jne	.print

		pop	si
		pop	ax
		ret



instdrop:	push	ax

		xor	ax, ax
		mov	[si], ax
		dec	si

		pop	ax
		ret


instinc:	push	ax
		
		lodsb
		inc	ax
		dec	si
		mov	[si], ax
		
		pop	ax
		ret


instdec:	push	ax
		
		lodsb
		dec	ax
		dec	si
		mov	[si], ax
		
		pop	ax
		ret


instbase:	inc	si
		mov	[si], di
		ret


insthere:	inc	si
		mov	[si], si
		ret

instload:;	push	ax

;		lodsw

;		mov	ax, [si]

		jmp	$
;		call	instdrop
		mov	si, ax

		pop	ax
		ret



langeval:;	push	ax
		mov	ax, [si]
		call	instdrop


		cmp	al, '_'
		je	.instdrop

		cmp	al, '.'
		je	.instout

		cmp	al, '+'
		je	.instinc

		cmp	al, '-'
		je	.instdec

		cmp	al, '?'
		je	.extprint

		cmp	al, '#'
		je	.instbase

		cmp	al, '@'
		je	.insthere

		cmp	al, '&'
		je	.instload

		cmp	al, '!'
		je	.insthlt


		inc	si
		mov	[si], ax

	;	pop	ax
		ret			; Exiting if no match


.instdrop:	call	instdrop
		ret

.instout:	call	instout
		call	instdrop
		ret

.instinc:	call	instinc
		ret

.instdec:	call	instdec
		ret

.extprint:	call	extprint
		ret
		
.instbase:	call	instbase
		ret

.insthere:	call	insthere
		ret

.instload:	call	instload
		ret

.insthlt:	jmp	$



times 510 - ($ - $$) db 0
dw 0xaa55
